import { Octokit } from '@octokit/rest';
import simpleGit from 'simple-git';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';

dotenv.config();

const git = simpleGit();

/**
 * Initialize GitHub client
 */
export function initGitHub() {
  if (!process.env.GITHUB_TOKEN) {
    throw new Error('GITHUB_TOKEN not found in .env file');
  }

  return new Octokit({
    auth: process.env.GITHUB_TOKEN,
  });
}

/**
 * Get the current repo info from git
 */
export async function getRepoInfo() {
  const remotes = await git.getRemotes(true);
  const origin = remotes.find(r => r.name === 'origin');
  
  if (!origin) {
    throw new Error('No origin remote found');
  }

  // Parse GitHub URL: https://github.com/owner/repo.git
  const match = origin.refs.fetch.match(/github\.com[:/](.+?)\/(.+?)(\.git)?$/);
  
  if (!match) {
    throw new Error('Could not parse GitHub repo from origin URL');
  }

  return {
    owner: match[1],
    repo: match[2],
  };
}

/**
 * Create a new branch for the fix
 */
export async function createFixBranch(serviceName) {
  const branchName = `codeflow/fix-${serviceName}-${Date.now()}`;
  
  console.log(`\nğŸŒ¿ Creating branch: ${branchName}`);
  
  await git.checkoutLocalBranch(branchName);
  
  return branchName;
}

/**
 * Apply the fix to a file
 */
export function applyFix(filePath, oldCode, newCode) {
  console.log(`\nâœï¸  Applying fix to ${filePath}`);
  
  const fullPath = path.resolve(filePath);
  let content = fs.readFileSync(fullPath, 'utf-8');
  
  // Simple string replacement (in production, you'd use AST manipulation)
  if (content.includes(oldCode)) {
    content = content.replace(oldCode, newCode);
    fs.writeFileSync(fullPath, content);
    return true;
  }
  
  return false;
}

/**
 * Commit and push changes
 */
export async function commitAndPush(branchName, serviceName, message) {
  console.log(`\nğŸ’¾ Committing changes...`);
  
  await git.add('.');
  await git.commit(`[CodeFlow] Fix ${serviceName}: ${message}`);
  
  console.log(`\nâ¬†ï¸  Pushing to GitHub...`);
  await git.push('origin', branchName);
  
  return true;
}

/**
 * Create a Pull Request
 */
export async function createPullRequest(octokit, repoInfo, branchName, serviceName, analysis, fix) {
  console.log(`\nğŸ”€ Creating Pull Request...`);

  const title = `[CodeFlow] Fix breaking change in ${serviceName}`;
  
  const body = `## ğŸ¤– CodeFlow Auto-Fix

This PR was automatically generated by CodeFlow to fix a breaking change.

### ğŸ“Š Analysis
${analysis}

### ğŸ”§ Fix Applied
${fix}

### âœ… What to do
1. Review the changes
2. Test locally if needed
3. Merge when ready

---
*Generated by CodeFlow AI*`;

  try {
    const { data } = await octokit.pulls.create({
      owner: repoInfo.owner,
      repo: repoInfo.repo,
      title: title,
      head: branchName,
      base: 'main',
      body: body,
    });

    console.log(`\nâœ… Pull Request created: ${data.html_url}`);
    return data;
  } catch (error) {
    console.error('âŒ Error creating PR:', error.message);
    throw error;
  }
}

/**
 * Main workflow: Detect, fix, and create PR
 */
export async function autoFixWorkflow(serviceName, filePath, oldCode, newCode, analysis, fix) {
  try {
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  CodeFlow Auto-Fix Workflow');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    // Initialize GitHub
    const octokit = initGitHub();
    const repoInfo = await getRepoInfo();
    
    console.log(`ğŸ“¦ Repository: ${repoInfo.owner}/${repoInfo.repo}`);

    // Create a new branch
    const branchName = await createFixBranch(serviceName);

    // Apply the fix
    const applied = applyFix(filePath, oldCode, newCode);
    
    if (!applied) {
      console.log('âŒ Could not apply fix - code pattern not found');
      return false;
    }

    // Commit and push
    await commitAndPush(branchName, serviceName, 'Update to match new API structure');

    // Create PR
    const pr = await createPullRequest(octokit, repoInfo, branchName, serviceName, analysis, fix);

    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  Auto-Fix Complete! ğŸ‰');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    return pr;
  } catch (error) {
    console.error('\nâŒ Workflow failed:', error.message);
    
    // Try to go back to main branch
    try {
      await git.checkout('main');
    } catch (e) {
      // Ignore
    }
    
    throw error;
  }
}
